use std::{ffi::OsStr, path::PathBuf};

use anyhow::anyhow;
use clap::Parser;
use collect::ClassNamesCollector;

use crate::transform::PrependClassNames;

#[derive(Parser)]
struct Cli {
    /// The output css file generated by calling `npx tailwindcss -i input.css -o output.css`
    #[arg(short = 'i')]
    css_file: PathBuf,

    /// The prefix to apply to all the classNames found
    #[arg(long)]
    prefix: String,

    /// The root directory of the js/ts project.
    context: PathBuf,
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    if !cli.context.is_dir() {
        return Err(anyhow!(
            "context should be a directory, got {}",
            cli.context.display()
        ));
    }

    let c = ClassNamesCollector::parse(cli.css_file)?;

    eprintln!("[INFO] extracted selectors");
    println!("{:?}", c.class_names);

    let mut ppc = PrependClassNames::new(&cli.prefix, c.class_names);

    for r in cli.context.read_dir()? {
        match r {
            Ok(entry) => {
                let filepath = entry.path();
                if let Some(ext) = filepath.extension() {
                    if !["ts", "js", "jsx", "tsx"].map(OsStr::new).contains(&ext) {
                        continue;
                    }
                }

                let output = ppc.prefix_classes(&filepath)?;

                std::fs::write(&filepath, &output)?;
                eprintln!("[INFO] transformed {}", filepath.display());
            }
            Err(err) => eprintln!("[Error] {err:#}"),
        };
    }

    Ok(())
}

mod collect {
    use std::path::PathBuf;
    use std::rc::Rc;

    use swc_common::errors::{ColorConfig, Handler};
    use swc_common::{FileName, SourceMap};
    use swc_css::visit::{Visit, VisitWith};

    use swc_css::{ast::Rule, parser::parse_file};

    pub struct ClassNamesCollector {
        pub class_names: Vec<String>,
    }

    impl ClassNamesCollector {
        pub fn new() -> Self {
            ClassNamesCollector {
                class_names: vec![],
            }
        }

        pub fn parse(css_file: PathBuf) -> anyhow::Result<Self> {
            let code = std::fs::read_to_string(&css_file)?;

            let options = swc_css::parser::parser::ParserConfig::default();

            let cm: Rc<SourceMap> = Default::default();
            let filename = FileName::Real(css_file);
            let cssfile = cm.new_source_file(filename.clone(), code);

            let handler =
                Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(cm.clone()));

            let mut errors = vec![];
            let c = parse_file::<Vec<Rule>>(&cssfile, None, options, &mut errors).unwrap();

            for e in errors {
                e.to_diagnostics(&handler).emit();
            }

            let mut ccns = ClassNamesCollector::new();

            c.visit_with(&mut ccns);

            Ok(ccns)
        }
    }

    impl Visit for ClassNamesCollector {
        fn visit_compound_selector(&mut self, n: &swc_css::ast::CompoundSelector) {
            let selectors = &n.subclass_selectors;

            selectors
                .iter()
                .filter_map(|s| match s {
                    swc_css::ast::SubclassSelector::Class(selector) => Some(selector),
                    _ => None,
                })
                .for_each(|s| {
                    if s.text.value.contains(':') {
                        let cn = s.text.value.split(':').last().unwrap();
                        self.class_names.push(cn.to_string());
                    } else {
                        self.class_names.push(s.text.value.to_string());
                    }
                });
        }
    }
}

mod transform {
    use anyhow::Context;
    use std::path::Path;
    use swc_atoms::Atom;
    use swc_common::sync::Lrc;
    use swc_common::{
        errors::{ColorConfig, Handler},
        SourceMap,
    };
    use swc_ecma_ast::JSXAttrName;
    use swc_ecma_codegen::text_writer;
    use swc_ecma_parser::{lexer::Lexer, Parser, StringInput, Syntax};
    use swc_ecma_visit::{VisitMut, VisitMutWith};

    pub struct PrependClassNames<'s> {
        pub prefix: &'s str,
        class_names: Vec<String>,
    }

    impl<'s> PrependClassNames<'s> {
        pub fn new(prefix: &'s str, class_names: Vec<String>) -> Self {
            Self {
                prefix,
                class_names,
            }
        }

        pub fn prefix_classes(&mut self, source_file: &Path) -> anyhow::Result<Vec<u8>> {
            let cm: Lrc<SourceMap> = Default::default();
            let handler =
                Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(cm.clone()));

            let fm = cm
                .load_file(source_file)
                .context("failed to load source file")?;

            let lexer = Lexer::new(
                Syntax::Typescript(swc_ecma_parser::TsConfig {
                    tsx: true,
                    ..Default::default()
                }),
                // EsVersion defaults to es5
                Default::default(),
                StringInput::from(&*fm),
                None,
            );

            let mut parser = Parser::new_from(lexer);

            for e in parser.take_errors() {
                e.into_diagnostic(&handler).emit();
            }

            let mut module = parser
                .parse_module()
                .map_err(|e| e.into_diagnostic(&handler).emit())
                .expect("failed to parser module");

            module.visit_mut_children_with(self);

            let mut output = Vec::new();
            let writer = text_writer::JsWriter::new(cm.clone(), "\n", &mut output, None);

            let mut emitter = swc_ecma_codegen::Emitter {
                cfg: Default::default(),
                cm: cm.clone(),
                comments: None,
                wr: Box::new(writer),
            };

            emitter
                .emit_module(&module)
                .context("failed to emit edit module")?;

            return Ok(output);
        }
    }

    impl<'s> VisitMut for PrependClassNames<'s> {
        fn visit_mut_jsx_attr(&mut self, n: &mut swc_ecma_ast::JSXAttr) {
            if let JSXAttrName::Ident(name) = &n.name {
                let ident = &name.sym;
                if ident.contains("class") || ident.contains("Class") {
                    n.value.visit_mut_with(self);
                }
            }
        }

        fn visit_mut_str(&mut self, n: &mut swc_ecma_ast::Str) {
            let replacements: Vec<_> = n
                .value
                .split(' ')
                .map(|class| {
                    let class = class.to_string();
                    if self.class_names.contains(&class) {
                        format!("{}{}", self.prefix, class)
                    } else {
                        class
                    }
                })
                .collect();

            let replacement = Atom::new(format!("\"{}\"", replacements.join(" ")));

            n.raw = Some(replacement)
        }
    }
}

#[cfg(test)]
mod tests {
    use assert_cmd::Command;
    use insta::assert_snapshot;
    use std::fs;

    #[test]
    fn parses_classname_from_selectors_and_transforms_js_files() {
        let js_file = "fixtures/sample.tsx";
        let js_file_content_before = fs::read(js_file).expect("failed to read js fixture file");

        let mut cmd = Command::cargo_bin("fcn").unwrap();
        let cmd = cmd
            .args(["-i", "fixtures/sample.css", "--prefix", "tw-", "fixtures"])
            .assert()
            .success();

        let output = cmd.get_output();

        let output = String::from_utf8_lossy(&output.stdout);

        assert_snapshot!(output);

        let js_file_content_after = fs::read(js_file).expect("failed to read js fixture file");
        let js_file_content_after = String::from_utf8_lossy(&js_file_content_after);

        insta::with_settings!({
            info => &output,
            description => String::from_utf8_lossy(&js_file_content_before),
        }, {
            assert_snapshot!(js_file_content_after);
        });

        fs::write(js_file, js_file_content_before).expect("failed to write back to edited file")
    }
}
